<!DOCTYPE html>
<html lang="zh-CN"> 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="pageTitle">QR-my-file | 敏捷二维码文件传输 | 扫码即传，无需应用</title>
    <meta id="metaDescription" name="description" content="通过二维码在设备间即时传输文件。小文件直接嵌入二维码，大文件（最大10MB）通过安全的临时链接分享。快速、简单，无需安装应用。">
    <meta id="metaKeywords" name="keywords" content="QR-my-file, 二维码文件传输, 二维码传文件, 跨设备文件共享, 扫码传文件, 静态文件传输, Indie Hacker, 敏捷传输">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://gosspublic.alicdn.com/aliyun-oss-sdk-6.18.0.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/js-md5/0.7.3/md5.min.js"></script> -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8MQHD5843Z"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8MQHD5843Z');
</script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        }
        .upload-area {
            border: 2px dashed #cbd5e1;
            transition: background-color 0.2s ease-in-out;
        }
        .upload-area.dragover {
            background-color: #e2e8f0;
            border-color: #94a3b8;
        }
        #qrCodeCanvas {
            display: block;
            width: 80%; 
            max-width: 420px; 
            margin: 20px auto; 
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }
        .btn {
            @apply py-2 px-4 rounded-lg font-semibold shadow-md transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-opacity-75;
        }
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500;
        }
        .btn-secondary {
            @apply bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-gray-400;
        }
        .btn-warning { /* New style for the feedback button */
            @apply bg-yellow-500 text-white hover:bg-yellow-600 focus:ring-yellow-400;
        }
        .loader {
            border: 4px solid #f3f3f3; 
            border-top: 4px solid #3498db; 
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .promo-list-item { 
            @apply mb-3 flex;
        }
        .promo-list-prefix { 
            @apply mr-2 text-blue-500 flex-shrink-0;
        }
        #poweredByText {
            @apply text-xs text-gray-500 mt-2 text-center;
        }
        .footer-link { /* Added for blog link styling */
            @apply text-blue-600 hover:text-blue-700 hover:underline;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white shadow-xl rounded-lg p-6 md:p-10 w-full max-w-2xl">
        <header class="text-center mb-8">
            <h1 id="mainHeading" class="text-3xl md:text-4xl font-bold text-blue-600">敏捷二维码文件传输</h1>
            <p id="subHeading" class="text-gray-600 mt-2">通过扫描二维码，在您的设备间轻松分享文件。</p>
        </header>

        <div id="senderView">
            <div id="uploadArea" class="upload-area p-8 text-center rounded-lg mb-6 cursor-pointer hover:bg-gray-50">
                <input type="file" id="fileInput" class="hidden">
                <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true">
                    <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
                <p class="mt-2 text-sm text-gray-600">
                    <span id="uploadInstructionClick" class="font-semibold text-blue-600">点击此处上传文件</span>
                    <span id="uploadInstructionDrag">或将文件拖拽到这里</span>
                </p>
                <p id="uploadHint" class="text-xs text-gray-500 mt-1">最大支持 10MB</p>
            </div>

            <div id="promoSection" class="my-8 text-gray-700">
                <div class="grid md:grid-cols-2 gap-x-8 gap-y-6 mb-8"> 
                    <div>
                        <h3 id="promoFeaturesTitle" class="text-xl font-semibold text-blue-600 mb-3">产品优势</h3>
                        <div class="text-sm space-y-2"> 
                            <div class="promo-list-item">
                                <span class="promo-list-prefix">*</span>
                                <div><strong id="feature1Title">扫码即传</strong><span id="feature1Desc">：告别App安装烦恼！手机电脑文件互传，从未如此敏捷。</span></div>
                            </div>
                            <div class="promo-list-item">
                                <span class="promo-list-prefix">*</span>
                                <div><strong id="feature2Title">真·跨平台</strong><span id="feature2Desc">：无需登录！打开浏览器就能用的文件传输利器，专注纯粹与高效。</span></div>
                            </div>
                            <div class="promo-list-item">
                                <span class="promo-list-prefix">*</span>
                                <div><strong id="feature3Title">免费·智能双通道</strong><span id="feature3Desc">：小文件『码』上秒传，10MB大文件云端直下，快慢兼顾皆免费！</span></div>
                            </div>
                            <div class="promo-list-item">
                                <span class="promo-list-prefix">*</span>
                                <div><strong id="feature4Title">万物皆可传</strong><span id="feature4Desc">：文档、图片、代码、压缩包…格式无忧，畅传无阻。</span></div>
                            </div>
                        </div>
                    </div>
                    <div>
                        <h3 id="promoStepsTitle" class="text-xl font-semibold text-blue-600 mb-3">操作步骤</h3>
                        <div class="text-sm space-y-2"> 
                            <div class="promo-list-item">
                                <span class="promo-list-prefix">*</span>
                                <div>
                                    <strong id="step1Title">第一步：选择文件</strong><br>
                                    <span id="step1Desc">轻松一点，您的专属文件二维码即刻呈现。</span>
                                </div>
                            </div>
                            <div class="promo-list-item">
                                <span class="promo-list-prefix">*</span>
                                <div>
                                    <strong id="step2Title">第二步：扫码获取</strong><br>
                                    <span id="step2Desc">使用手机、平板或电脑扫描二维码，文件立传/下载。</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="fileInfo" class="text-sm text-gray-700 mb-4 hidden">
                <p><strong id="labelFileName">文件名:</strong> <span id="fileName"></span></p>
                <p><strong id="labelFileSize">大小:</strong> <span id="fileSize"></span></p>
                <p><strong id="labelFileType">类型:</strong> <span id="fileType"></span></p>
            </div>
            
            <div id="statusMessage" class="text-sm my-4 p-3 rounded-md hidden"></div>
            <div class="text-center">
                <button id="largeFileFeedbackButton" class="btn btn-warning mt-2 hidden"></button>
                <p id="feedbackConfirmationMessage" class="text-sm text-green-600 mt-2 hidden"></p>
            </div>
            <div id="loader" class="loader hidden"></div>

            <div id="qrCodeContainer" class="text-center hidden">
                <h2 id="scanQrInstruction" class="text-xl font-semibold mb-2 text-gray-700">扫描二维码接收文件</h2>
                <canvas id="qrCodeCanvas"></canvas>
                <p id="poweredByText"></p> 
                <button id="resetButton" class="btn btn-secondary mt-4">传输新文件</button>
            </div>
        </div>

        <div id="receiverView" class="hidden text-center">
            <h2 id="receiverTitle" class="text-2xl font-semibold mb-6 text-gray-700">正在接收文件...</h2>
            <div id="receiverLoader" class="loader"></div>
            <div id="receiverStatusMessage" class="text-sm my-4 p-3 rounded-md hidden"></div>
            
            <div id="filePreview" class="mb-6 border rounded-lg p-4 max-h-96 overflow-auto hidden bg-gray-50">
            </div>

            <a id="downloadButton" href="#" class="btn btn-primary hidden" download>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
                <span id="downloadButtonText">下载文件</span>
            </a>
            <p id="receiverNote" class="text-xs text-gray-500 mt-2 hidden"></p>
            <button id="receiveNewButton" class="btn btn-secondary mt-6" onclick="window.location.href=window.location.pathname">
                <span id="scanAnotherQrText">扫描其他二维码</span>
            </button>
        </div>

        <footer class="text-center mt-10 pt-6 border-t border-gray-200">
            <p class="text-sm text-gray-500 mb-2">&copy; <span id="currentYear"></span> <span id="footerText">qrmyfile.com</span></p>
            <p class="text-sm text-gray-500">
                <a href="https://qrmyfile.github.io/" target="_blank" rel="noopener noreferrer" id="blogLink" class="footer-link">博客</a>
            </p>
        </footer>
    </div>

    <script>
        // --- 配置常量 ---
        const FC_TOKEN_ENDPOINT = 'https://tmp-token-gen-ezgvuegkbx.cn-shanghai.fcapp.run'; 
        const REGION_INFO_ENDPOINT = 'https://oss.qrmyfile.com'; 
        const MAX_DIRECT_URL_LENGTH_BYTES = 2 * 1024; 
        const MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; 
        const TRACKING_ENDPOINT_BASE = 'http://qrshare.cn-shanghai.log.aliyuncs.com/logstores/track/track?APIVersion=0.6.0';

        // --- 语言包 ---
        const translations = {
            en: {
                pageTitle: "QR-my-file | Agile QR File Transfer | Scan & Send, No App Needed", 
                metaDescription: "Instantly transfer files between devices using QR codes. Small files are embedded directly, large files (up to 10MB) shared via secure temporary links. Fast, simple, no app installation required.",
                metaKeywords: "QR-my-file, QR code file transfer, send file by QR, cross-device file sharing, scan to send file, static file transfer, Indie Hacker, agile transfer, ZIP transfer", 
                mainHeading: "Agile QR File Transfer",
                subHeading: "Easily share files between your devices by scanning a QR code.",
                uploadInstructionClick: "Click here to select a file to share",
                uploadInstructionDrag: "or drag and drop a file here",
                uploadHint: "Max 10MB",
                labelFileName: "Filename:",
                labelFileSize: "Size:",
                labelFileType: "Type:",
                unknownFileType: "Unknown type",
                scanQrInstruction: "Scan QR Code to Receive File",
                poweredByText: "Powered by qrmyfile.com", 
                resetButton: "Transfer New File",
                largeFileFeedbackButtonText: "File over 10MB? Click to request support", 
                feedbackConfirmationText: "Thank you for your feedback!", 
                receiverTitleInitial: "Receiving file...", 
                receiverTitleDirectLink: "Ready to process file from QR code...", 
                downloadButtonText: "Download File",
                scanAnotherQrText: "Scan Another QR Code",
                footerText: "qrmyfile.com", 
                blogLinkText: "Learn more from blog", // Added blog link text
                previewLabel: (fileName) => `Preview: ${fileName}`,
                // Promo Text
                promoFeaturesTitle: "Core Advantages",
                feature1Title: "Scan & Send",
                feature1Desc: ": Ditch app installs! Effortless file transfer between phone and PC, more agile than ever.",
                feature2Title: "True Cross-Platform",
                feature2Desc: ": No login needed! A file transfer tool that works right in your browser, focusing on purity and efficiency.",
                feature3Title: "Free & Smart Dual-Channel",
                feature3Desc: ": Small files transfer instantly via QR, 10MB large files download directly from the cloud—fast or large, always free!",
                feature4Title: "Transfer Anything",
                feature4Desc: ": Documents, images, code, archives... No format worries, transfer freely.",
                promoStepsTitle: "How It Works",
                step1Title: "Step 1: Select File",
                step1Desc: "One simple click, and your exclusive file QR code appears instantly.",
                step2Title: "Step 2: Scan to Get",
                step2Desc: "Use your phone, tablet, or computer to scan the QR code for instant file transfer/download.",
                // Dynamic messages
                statusProcessingFile: "Processing file...",
                statusCompressionDone: (size) => `ZIP compression complete (archive size: ${size}). Checking URL length...`, 
                statusUrlTooLongForDirect: (limitKB) => `Direct transfer URL would be too long (>${limitKB}KB). Switching to OSS for direct link.`, 
                statusQrGenerated: "QR code generated! Please scan with another device.",
                statusOssGetPerms: "Getting OSS upload permission...",
                statusOssPermsDone: "Permission granted. Uploading to OSS...",
                statusOssUploaded: "File is Ready to share,QR generated! Please scan with another device.", 
                statusFileDecoded: "ZIP file decoded and uncompressed.", 
                statusLinkReady: "File link ready. Click to download.", 
                errorFileTooLarge: (maxSize) => `File too large (max ${maxSize}).`, 
                errorFileProcessing: (message) => `File processing failed: ${message}`, 
                errorGenericNetwork: "A network or server error occurred. Please try again later.", 
                errorGenericProcessing: "An error occurred while processing your file. Please try again.", 
                errorFcRequest: (statusText) => `Failed to get OSS credentials from Function Compute: ${statusText}`, 
                errorOssCredsFormat: "Incorrect OSS credential format received.", 
                errorOssOperation: (message) => `OSS operation failed: ${message}`, 
                errorOssUpload: (statusMessage) => `OSS upload failed: ${statusMessage}`, 
                errorReceiveFile: (message) => `Error: ${message}`,
                errorInvalidDataFormat: "Invalid file data format received from QR code.",
                errorJsonParse: (message) => `Failed to parse file data: ${message}`,
                errorAtob: (message) => `Base64 decoding failed: ${message}`, 
                errorZipProcessing: (message) => `ZIP file processing failed: ${message}`, 
                errorFileNotFoundInZip: "File not found within the ZIP archive.", 
                errorRegionInfo: "Failed to retrieve OSS region information.", 
                receiverTitleReceiving: (fileName) => `Receiving: ${fileName}`,
                receiverTitleDownloadReady: (fileName) => `Download ready: ${fileName}`, 
                receiverTitleError: "Failed to receive file",
                receiverNoteOss: "This is a ZIP file (.zip). You may need to decompress it manually after downloading.", 
                guessedFileNameOss: "file_from_cloud.zip" 
            },
            zh: {
                pageTitle: "QR-my-file | 敏捷二维码文件传输 | 扫码即传，无需应用", 
                metaDescription: "通过二维码在设备间即时传输文件。小文件直接嵌入二维码，大文件（最大10MB）通过安全的临时链接分享。快速、简单，无需安装应用。",
                metaKeywords: "QR-my-file, 二维码文件传输, 二维码传文件, 跨设备文件共享, 扫码传文件, 静态文件传输, Indie Hacker, 敏捷传输, ZIP传输", 
                mainHeading: "敏捷二维码文件传输",
                subHeading: "通过扫描二维码，在您的设备间轻松分享文件。",
                uploadInstructionClick: "点击此处上选择要共享的文件",
                uploadInstructionDrag: "或将文件拖拽到这里",
                uploadHint: "最大支持 10MB",
                labelFileName: "文件名:",
                labelFileSize: "大小:",
                labelFileType: "类型:",
                unknownFileType: "未知类型",
                scanQrInstruction: "扫描二维码接收文件",
                poweredByText: "由 qrmyfile.com 驱动", 
                resetButton: "传输新文件",
                largeFileFeedbackButtonText: "文件超10MB？点此反馈", 
                feedbackConfirmationText: "感谢您的反馈！", 
                receiverTitleInitial: "正在接收文件...", 
                receiverTitleDirectLink: "准备处理来自二维码的文件...", 
                downloadButtonText: "下载文件",
                scanAnotherQrText: "扫描其他二维码",
                footerText: "qrmyfile.com", 
                blogLinkText: "从博客了解更多", // Added blog link text
                previewLabel: (fileName) => `预览: ${fileName}`,
                // Promo Text
                promoFeaturesTitle: "产品优势",
                feature1Title: "扫码即传",
                feature1Desc: "：告别App安装烦恼！手机电脑文件互传，从未如此敏捷。",
                feature2Title: "真·跨平台",
                feature2Desc: "：无需登录！打开浏览器就能用的文件传输利器，专注纯粹与高效。",
                feature3Title: "免费·智能双通道",
                feature3Desc: "：小文件『码』上秒传，10MB大文件云端直下，快慢兼顾皆免费！",
                feature4Title: "万物皆可传",
                feature4Desc: "：文档、图片、代码、压缩包…格式无忧，畅传无阻。",
                promoStepsTitle: "操作步骤",
                step1Title: "第一步：选择文件",
                step1Desc: "轻松一点，您的专属文件二维码即刻呈现。",
                step2Title: "第二步：扫码获取",
                step2Desc: "使用手机、平板或电脑扫描二维码，文件立传/下载。",
                // Dynamic messages
                statusProcessingFile: "正在处理文件...",
                statusCompressionDone: (size) => `ZIP 压缩完成 (压缩包大小: ${size})。正在检查URL长度...`, 
                statusUrlTooLongForDirect: (limitKB) => `直接传输的URL将过长 (>${limitKB}KB)，切换到OSS直链传输。`, 
                statusQrGenerated: "二维码已生成！请使用另一台设备扫描。",
                statusOssGetPerms: "正在获取OSS上传许可...",
                statusOssPermsDone: "许可获取成功，正在上传至OSS...",
                statusOssUploaded: "文件已经可供下载，请扫描二维码！", 
                statusFileDecoded: "ZIP 文件已解码并解压。", 
                statusLinkReady: "文件链接已准备好，请点击下载。", 
                errorFileTooLarge: (maxSize) => `文件过大 (最大 ${maxSize})。`, 
                errorFileProcessing: (message) => `文件处理失败: ${message}`, 
                errorGenericNetwork: "网络或服务器错误，请稍后重试。", 
                errorGenericProcessing: "处理文件时发生错误，请重试。", 
                errorFcRequest: (statusText) => `从函数计算获取OSS凭证失败: ${statusText}`, 
                errorOssCredsFormat: "获取到的OSS凭证格式不正确。", 
                errorOssOperation: (message) => `OSS 操作失败: ${message}`, 
                errorOssUpload: (statusMessage) => `OSS上传失败: ${statusMessage}`, 
                errorReceiveFile: (message) => `错误: ${message}`, 
                errorInvalidDataFormat: "从二维码获取的文件数据格式无效。",
                errorJsonParse: (message) => `解析文件数据失败: ${message}`,
                errorAtob: (message) => `Base64 解码失败: ${message}`, 
                errorZipProcessing: (message) => `ZIP 文件处理失败: ${message}`, 
                errorFileNotFoundInZip: "在 ZIP 压缩包中未找到文件。", 
                errorRegionInfo: "获取OSS区域信息失败。", 
                receiverTitleReceiving: (fileName) => `正在接收: ${fileName}`,
                receiverTitleDownloadReady: (fileName) => `准备下载: ${fileName}`, 
                receiverTitleError: "接收文件失败",
                receiverNoteOss: "这是一个 ZIP 文件 (.zip)，下载后您可能需要手动解压缩。", 
                guessedFileNameOss: "来自云端的文件.zip" 
            }
        };
        let currentLang = 'zh'; 

        function trackEvent(eventName, params = {}) {
            try {
                const trackingParams = {
                    ev: eventName,
                    ts: new Date().toISOString(),
                    lg: currentLang,
                    ua: encodeURIComponent(navigator.userAgent),
                    pg: encodeURIComponent(window.location.href),
                    ...params 
                };
                const queryString = Object.keys(trackingParams)
                    .map(key => `${key}=${trackingParams[key]}`)
                    .join('&');
                const beaconUrl = `${TRACKING_ENDPOINT_BASE}&${queryString}`;
                const img = new Image();
                img.src = beaconUrl;
            } catch (e) {
                console.warn("Tracking event failed:", e);
            }
        }

        function getText(key, ...args) {
            const langPack = translations[currentLang] || translations.en; 
            let text = langPack[key] || key; 
            if (typeof text === 'function') {
                return text(...args);
            }
            return text;
        }
        
        const pageTitleElem = document.getElementById('pageTitle');
        const metaDescriptionElem = document.getElementById('metaDescription');
        const metaKeywordsElem = document.getElementById('metaKeywords');
        const mainHeadingElem = document.getElementById('mainHeading');
        const subHeadingElem = document.getElementById('subHeading');
        const uploadInstructionClickElem = document.getElementById('uploadInstructionClick');
        const uploadInstructionDragElem = document.getElementById('uploadInstructionDrag');
        const uploadHintElem = document.getElementById('uploadHint');
        const labelFileNameElem = document.getElementById('labelFileName');
        const labelFileSizeElem = document.getElementById('labelFileSize');
        const labelFileTypeElem = document.getElementById('labelFileType');
        const scanQrInstructionElem = document.getElementById('scanQrInstruction');
        const resetButtonElem = document.getElementById('resetButton'); 
        const receiverTitleElem = document.getElementById('receiverTitle'); 
        const downloadButtonTextElem = document.getElementById('downloadButtonText');
        const scanAnotherQrTextElem = document.getElementById('scanAnotherQrText');
        const footerTextElem = document.getElementById('footerText');
        const poweredByTextElem = document.getElementById('poweredByText'); 
        const largeFileFeedbackButton = document.getElementById('largeFileFeedbackButton'); 
        const feedbackConfirmationMessage = document.getElementById('feedbackConfirmationMessage'); 
        const blogLinkElem = document.getElementById('blogLink');


        // Promo text elements
        const promoFeaturesTitleElem = document.getElementById('promoFeaturesTitle');
        const feature1TitleElem = document.getElementById('feature1Title'); 
        const feature1DescElem = document.getElementById('feature1Desc');   
        const feature2TitleElem = document.getElementById('feature2Title');
        const feature2DescElem = document.getElementById('feature2Desc');
        const feature3TitleElem = document.getElementById('feature3Title');
        const feature3DescElem = document.getElementById('feature3Desc');
        const feature4TitleElem = document.getElementById('feature4Title');
        const feature4DescElem = document.getElementById('feature4Desc');

        const promoStepsTitleElem = document.getElementById('promoStepsTitle');
        const step1TitleElem = document.getElementById('step1Title');
        const step1DescElem = document.getElementById('step1Desc');
        const step2TitleElem = document.getElementById('step2Title');
        const step2DescElem = document.getElementById('step2Desc');
        const promoSection = document.getElementById('promoSection');


        const senderView = document.getElementById('senderView');
        const receiverView = document.getElementById('receiverView');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileNameDisplay = document.getElementById('fileName');
        const fileSizeDisplay = document.getElementById('fileSize');
        const fileTypeDisplay = document.getElementById('fileType');
        const statusMessage = document.getElementById('statusMessage');
        const loader = document.getElementById('loader');
        const qrCodeContainer = document.getElementById('qrCodeContainer');
        const qrCodeCanvas = document.getElementById('qrCodeCanvas');
        
        const receiverLoader = document.getElementById('receiverLoader');
        const receiverStatusMessage = document.getElementById('receiverStatusMessage');
        const filePreview = document.getElementById('filePreview');
        const downloadButton = document.getElementById('downloadButton');
        const receiverNote = document.getElementById('receiverNote');
        
        let originalFileNameForFeedback = ''; 
        let originalFileSizeForFeedback = 0; 
        
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        document.addEventListener('DOMContentLoaded', initApp);

        function setLanguage() {
            const browserLang = navigator.language || navigator.userLanguage; 
            if (browserLang.startsWith('en')) {
                currentLang = 'en';
            } else if (browserLang.startsWith('zh')) {
                currentLang = 'zh';
            } else {
                currentLang = 'en'; 
            }
            document.documentElement.lang = currentLang.startsWith('zh') ? 'zh-CN' : currentLang; 
        }

        function translateUI() {
            pageTitleElem.textContent = getText('pageTitle');
            metaDescriptionElem.content = getText('metaDescription');
            metaKeywordsElem.content = getText('metaKeywords');
            mainHeadingElem.textContent = getText('mainHeading');
            subHeadingElem.textContent = getText('subHeading');
            uploadInstructionClickElem.textContent = getText('uploadInstructionClick');
            uploadInstructionDragElem.textContent = getText('uploadInstructionDrag');
            uploadHintElem.textContent = getText('uploadHint');
            labelFileNameElem.textContent = getText('labelFileName');
            labelFileSizeElem.textContent = getText('labelFileSize');
            labelFileTypeElem.textContent = getText('labelFileType');
            scanQrInstructionElem.textContent = getText('scanQrInstruction');
            if (poweredByTextElem) poweredByTextElem.textContent = getText('poweredByText'); 
            resetButtonElem.textContent = getText('resetButton'); 
            if (largeFileFeedbackButton) largeFileFeedbackButton.textContent = getText('largeFileFeedbackButtonText');
            if (feedbackConfirmationMessage) feedbackConfirmationMessage.textContent = getText('feedbackConfirmationText');
            if (blogLinkElem) blogLinkElem.textContent = getText('blogLinkText');


            const urlParamsForTitle = new URLSearchParams(window.location.search);
            if (urlParamsForTitle.has('file')) {
                 receiverTitleElem.textContent = getText('receiverTitleInitial');
            } else {
                 receiverTitleElem.textContent = getText('receiverTitleDirectLink');
            }
            downloadButtonTextElem.textContent = getText('downloadButtonText');
            scanAnotherQrTextElem.textContent = getText('scanAnotherQrText');
            footerTextElem.textContent = getText('footerText');

            // Translate promo text
            promoFeaturesTitleElem.textContent = getText('promoFeaturesTitle');
            feature1TitleElem.textContent = getText('feature1Title');
            feature1DescElem.textContent = getText('feature1Desc');
            feature2TitleElem.textContent = getText('feature2Title');
            feature2DescElem.textContent = getText('feature2Desc');
            feature3TitleElem.textContent = getText('feature3Title');
            feature3DescElem.textContent = getText('feature3Desc');
            feature4TitleElem.textContent = getText('feature4Title');
            feature4DescElem.textContent = getText('feature4Desc');

            promoStepsTitleElem.textContent = getText('promoStepsTitle');
            step1TitleElem.textContent = getText('step1Title');
            step1DescElem.textContent = getText('step1Desc');
            step2TitleElem.textContent = getText('step2Title');
            step2DescElem.textContent = getText('step2Desc');
        }

        function initApp() {
            setLanguage();
            translateUI(); 

            const urlParams = new URLSearchParams(window.location.search);
            let mode = 'sender';
            if (urlParams.has('file')) {
                mode = 'receiver';
                senderView.classList.add('hidden');
                receiverView.classList.remove('hidden');
                if(promoSection) promoSection.classList.add('hidden'); 
            } else {
                receiverView.classList.add('hidden');
                senderView.classList.remove('hidden');
                if(promoSection) promoSection.classList.remove('hidden'); 
                setupSenderEventListeners();
            }
            trackEvent('load', { md: mode });
        }

        function setupSenderEventListeners() {
            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileUpload);
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
            });
            uploadArea.addEventListener('drop', handleDrop, false);

            resetButtonElem.addEventListener('click', () => { 
                if(promoSection) promoSection.classList.remove('hidden'); 
                if(largeFileFeedbackButton) largeFileFeedbackButton.classList.add('hidden');
                if(feedbackConfirmationMessage) feedbackConfirmationMessage.classList.add('hidden');
                window.location.href = window.location.pathname; 
            });

            if (largeFileFeedbackButton) {
                largeFileFeedbackButton.addEventListener('click', () => {
                    trackEvent('req_lg_file', {
                        fn: encodeURIComponent(originalFileNameForFeedback),
                        fs: originalFileSizeForFeedback
                    });
                    if(feedbackConfirmationMessage) {
                        feedbackConfirmationMessage.classList.remove('hidden');
                        setTimeout(() => {
                            feedbackConfirmationMessage.classList.add('hidden');
                        }, 3000); 
                    }
                    largeFileFeedbackButton.classList.add('hidden'); 
                });
            }
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) {
                fileInput.files = files; 
                handleFileUpload({ target: fileInput }); 
            }
        }

        function showStatus(element, messageKey, isError = false, ...args) {
            element.textContent = getText(messageKey, ...args); 
            element.classList.remove('hidden', 'bg-green-100', 'text-green-700', 'bg-red-100', 'text-red-700');
            if (isError) {
                element.classList.add('bg-red-100', 'text-red-700');
            } else {
                element.classList.add('bg-green-100', 'text-green-700');
            }
            element.classList.remove('hidden');
        }

        function hideStatus(element) {
            element.classList.add('hidden');
        }

        function showLoader(loaderElement, show = true) {
            loaderElement.classList.toggle('hidden', !show);
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if(promoSection) promoSection.classList.add('hidden'); 
            if(largeFileFeedbackButton) largeFileFeedbackButton.classList.add('hidden'); 
            if(feedbackConfirmationMessage) feedbackConfirmationMessage.classList.add('hidden');


            trackEvent('select', { 
                fn: encodeURIComponent(file.name), 
                fs: file.size 
            });

            hideStatus(statusMessage);
            qrCodeContainer.classList.add('hidden');
            fileInfo.classList.remove('hidden');
            fileNameDisplay.textContent = file.name;
            fileSizeDisplay.textContent = formatBytes(file.size);
            fileTypeDisplay.textContent = file.type || getText('unknownFileType');

            originalFileNameForFeedback = file.name; 
            originalFileSizeForFeedback = file.size;

            if (file.size > MAX_FILE_SIZE_BYTES) {
                const userMessageKey = 'errorFileTooLarge';
                showStatus(statusMessage, userMessageKey, true, formatBytes(MAX_FILE_SIZE_BYTES));
                if (largeFileFeedbackButton) {
                    largeFileFeedbackButton.classList.remove('hidden'); 
                }
                trackEvent('error', { 
                    ec: 'FILE_TOO_LARGE', 
                    em: userMessageKey, 
                    fn: encodeURIComponent(file.name), 
                    fs: file.size 
                });
                fileInfo.classList.add('hidden');
                fileInput.value = ''; 
                return;
            }

            showLoader(loader, true);
            showStatus(statusMessage, "statusProcessingFile", false);

            try {
                const arrayBuffer = await file.arrayBuffer();
                
                const zip = new JSZip();
                zip.file(file.name, arrayBuffer, { compression: "DEFLATE" }); 
                const compressedZipData = await zip.generateAsync({ type: "uint8array", compression: "DEFLATE" });

                showStatus(statusMessage, 'statusCompressionDone', false, formatBytes(compressedZipData.length));

                let binary = '';
                const bytes = compressedZipData; 
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                let base64Data = window.btoa(binary);
                const safeBase64Data = base64Data.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '.');

                const payload = {
                    name: file.name, 
                    type: file.type || 'application/octet-stream', 
                    data: safeBase64Data 
                };
                const jsonString = JSON.stringify(payload);
                const finalUrlParam = encodeURIComponent(jsonString);
                const directUrl = `${window.location.origin}${window.location.pathname}?file=${finalUrlParam}`;

                if (directUrl.length < MAX_DIRECT_URL_LENGTH_BYTES) {
                    displayQrCode(directUrl); 
                    showStatus(statusMessage, "statusQrGenerated", false);
                    trackEvent('qr_direct', { 
                        fn: encodeURIComponent(file.name), 
                        fs: file.size, 
                        zs: compressedZipData.length,
                        tt: 'direct'
                    });
                    showLoader(loader, false);
                } else {
                    showStatus(statusMessage, 'statusUrlTooLongForDirect', true, (MAX_DIRECT_URL_LENGTH_BYTES / 1024).toFixed(0));
                    await uploadToOssAndGetUrl(compressedZipData, file.name); 
                }
            } catch (error) {
                console.error("File processing failed (ZIP or Base64):", error);
                const userMessageKey = 'errorGenericProcessing';
                showStatus(statusMessage, userMessageKey, true);
                trackEvent('error', { 
                    ec: 'PROC_ZIP_B64', 
                    em: userMessageKey, 
                    details: encodeURIComponent(error.message) 
                });
                showLoader(loader, false);
                fileInfo.classList.add('hidden');
            }
        }
        
        async function getOssCredentials(originalFileName, zipDataForUpload) {
            let regionInfo, fcCredentials;
            let derivedRegion, derivedBucket, derivedEndpoint;
            const userFriendlyErrorKey = 'errorGenericNetwork'; 

            try {
                const regionResponse = await fetch(REGION_INFO_ENDPOINT);
                if (!regionResponse.ok) {
                    const errorText = await regionResponse.text();
                    console.error("Region Info Fetch Error:", regionResponse.status, errorText);
                    trackEvent('error', { ec: 'REG_FETCH_ERR', em: userFriendlyErrorKey, details: encodeURIComponent(`${regionResponse.status} ${errorText}`)});
                    throw new Error(getText(userFriendlyErrorKey));
                }
                regionInfo = await regionResponse.json();
                if (!regionInfo || !regionInfo.oss_region) { 
                    console.error("Region Info Format Error or missing oss_region:", regionInfo);
                    trackEvent('error', { ec: 'REG_FMT_ERR', em: userFriendlyErrorKey, details: "oss_region missing or invalid format" });
                    throw new Error(getText(userFriendlyErrorKey));
                }
                derivedRegion = regionInfo.oss_region;
                derivedBucket = `qrshare-${derivedRegion}`;
                derivedEndpoint = `oss-${derivedRegion}.aliyuncs.com`;

            } catch (error) {
                if (!error.message.includes(getText(userFriendlyErrorKey))) { 
                    console.error("Fetch REGION_INFO_ENDPOINT failed:", error);
                    trackEvent('error', { ec: 'REG_NET_ERR', em: userFriendlyErrorKey, details: encodeURIComponent(error.message) });
                    throw new Error(getText(userFriendlyErrorKey));
                }
                throw error; 
            }

            const zipFileMd5 = "abc"; // Hardcoded MD5
            const zipFileSize = zipDataForUpload.length;
            const requestBody = {
                fileName: originalFileName, 
                fileSize: zipFileSize,    
                fileMd5: zipFileMd5       
            };

            try {
                const fcResponse = await fetch(FC_TOKEN_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                if (!fcResponse.ok) {
                    const errorText = await fcResponse.text();
                    console.error("FC Request Error:", fcResponse.status, errorText);
                    trackEvent('error', { ec: 'FC_REQ_FAIL', em: userFriendlyErrorKey, details: encodeURIComponent(`${fcResponse.status} ${errorText}`) });
                    throw new Error(getText(userFriendlyErrorKey));
                }
                fcCredentials = await fcResponse.json();
                if (!fcCredentials || !fcCredentials.AccessKeyId || !fcCredentials.AccessKeySecret || !fcCredentials.SecurityToken) { 
                    console.error("FC Credential Format Error:", fcCredentials);
                    trackEvent('error', { ec: 'FC_CRED_FMT', em: userFriendlyErrorKey, details: "Missing essential STS token fields" });
                    throw new Error(getText(userFriendlyErrorKey));
                }
            } catch (error) {
                 if (!error.message.includes(getText(userFriendlyErrorKey))) {
                    console.error("Fetch FC_TOKEN_ENDPOINT failed or JSON parsing error:", error);
                    trackEvent('error', { ec: 'FC_TOKEN_NET_PARSE_ERR', em: userFriendlyErrorKey, details: encodeURIComponent(error.message) });
                    throw new Error(getText(userFriendlyErrorKey));
                }
                throw error;
            }

            return {
                Region: derivedRegion, 
                Endpoint: derivedEndpoint, 
                Bucket: derivedBucket, 
                AccessKeyId: fcCredentials.AccessKeyId,
                AccessKeySecret: fcCredentials.AccessKeySecret,
                SecurityToken: fcCredentials.SecurityToken,
                Expiration: fcCredentials.Expiration 
            };
        }
        
        async function uploadToOssAndGetUrl(zipDataToUpload, originalFileName) {
            let userMessageKey = 'errorGenericNetwork'; 
            let errorCode = 'OSS_INIT_FAIL'; 
            try {
                showStatus(statusMessage, "statusOssGetPerms", false); 
                const creds = await getOssCredentials(originalFileName, zipDataToUpload);
                
                showStatus(statusMessage, "statusOssPermsDone", false);
                errorCode = 'OSS_CLIENT_INIT'; 

                const client = new OSS({
                    region: creds.Region, 
                    accessKeyId: creds.AccessKeyId,
                    accessKeySecret: creds.AccessKeySecret,
                    stsToken: creds.SecurityToken,
                    bucket: creds.Bucket, 
                    endpoint: creds.Endpoint, 
                    secure: true 
                });
                errorCode = 'OSS_PUT_OP'; 

                const uniqueOssObjectName = `${Date.now()}-${Math.random().toString(36).substring(2, 10)}-${originalFileName}.zip`;
                const blobToUpload = new Blob([zipDataToUpload], { type: 'application/zip' }); 
                const result = await client.put(uniqueOssObjectName, blobToUpload); 

                if (result.res.status !== 200) {
                    console.error("OSS Upload Error - Status:", result.res.status, result.res.statusMessage, result); 
                    errorCode = 'OSS_PUT_STAT_ERR';
                    throw new Error(getText(userMessageKey)); 
                }
                
                errorCode = 'OSS_SIGNURL_OP'; 
                const signedOssUrl = client.signatureUrl(uniqueOssObjectName, { expires: 3600 }); 
                
                displayQrCode(signedOssUrl); 
                showStatus(statusMessage, "statusOssUploaded", false); 
                trackEvent('qr_oss', { 
                    fn: encodeURIComponent(originalFileName), 
                    zs: zipDataToUpload.length, 
                    tt: 'oss'
                });

            } catch (error) {
                console.error(`OSS operation failed at step ${errorCode}:`, error.message); 
                const finalUserMessage = error.message.startsWith(getText('errorGenericNetwork').substring(0,10)) 
                                       ? error.message 
                                       : getText(userMessageKey);
                showStatus(statusMessage, finalUserMessage, true); 
                
                if (errorCode.startsWith('OSS_')) { 
                    trackEvent('error', { 
                        ec: errorCode, 
                        em: userMessageKey, 
                        details: encodeURIComponent(error.message) 
                    });
                }
            } finally {
                showLoader(loader, false); 
            }
        }

        function displayQrCode(url) {
            const canvasElement = document.getElementById('qrCodeCanvas');
            qrCodeContainer.classList.remove('hidden'); 
            
            const existingPoweredBy = document.getElementById('dynamicPoweredByText');
            if (existingPoweredBy) {
                existingPoweredBy.remove(); 
            }
            
            const drawingSurfaceWidth = canvasElement.clientWidth;

            new QRious({
                element: canvasElement,
                value: url,
                size: Math.max(150, Math.floor(drawingSurfaceWidth)), 
                level: 'L', 
                padding: 10, 
                background: '#ffffff',
                foreground: '#000000'
            });

            if (poweredByTextElem) { 
                 poweredByTextElem.textContent = getText('poweredByText');
                 poweredByTextElem.classList.remove('hidden');
            }
        }

        async function handleReceiverMode(urlParams) {
            showLoader(receiverLoader, true);
            if (urlParams.has('file')) {
                receiverTitleElem.textContent = getText('receiverTitleInitial');
            } else {
                receiverTitleElem.textContent = getText('receiverTitleDirectLink');
            }

            try {
                if (urlParams.has('file')) {
                    const encodedJsonPayload = urlParams.get('file'); 
                    let payload;
                    try {
                        payload = JSON.parse(encodedJsonPayload);
                    } catch (e) {
                        console.error("JSON parsing error:", e, "Payload was:", encodedJsonPayload);
                        const userMessageKey = 'errorJsonParse';
                        trackEvent('error', { ec: 'JSON_PARSE', em: userMessageKey, details: encodeURIComponent(e.message) });
                        throw new Error(getText(userMessageKey, e.message)); 
                    }

                    if (!payload || typeof payload.name !== 'string' || typeof payload.type !== 'string' || typeof payload.data !== 'string') {
                        const userMessageKey = 'errorInvalidDataFormat';
                        trackEvent('error', { ec: 'INVALID_PAYLOAD', em: userMessageKey });
                        throw new Error(getText(userMessageKey));
                    }

                    const receivedOriginalFileName = payload.name; 
                    const receivedOriginalFileType = payload.type; 
                    let safeBase64ZipData = payload.data;      
                    
                    receiverTitleElem.textContent = getText('receiverTitleReceiving', receivedOriginalFileName);
                    
                    const originalBase64ZipData = safeBase64ZipData.replace(/-/g, '+').replace(/_/g, '/').replace(/\./g, '=');

                    let binaryZipString;
                    try {
                        binaryZipString = window.atob(originalBase64ZipData); 
                    } catch (e) {
                        console.error("atob decoding error:", e, "Original Base64 was:", originalBase64ZipData);
                        const userMessageKey = 'errorAtob';
                        trackEvent('error', { ec: 'ATOB_FAIL', em: userMessageKey, details: encodeURIComponent(e.message) });
                        throw new Error(getText(userMessageKey, e.message));
                    }
                    
                    const len = binaryZipString.length;
                    const zipFileBytes = new Uint8Array(len); 
                    for (let i = 0; i < len; i++) {
                        zipFileBytes[i] = binaryZipString.charCodeAt(i);
                    }
                    
                    try {
                        const zip = new JSZip();
                        const loadedZip = await zip.loadAsync(zipFileBytes);
                        let fileInZip = loadedZip.file(receivedOriginalFileName);
                        if (!fileInZip) { 
                             const filesInZip = Object.keys(loadedZip.files);
                             if (filesInZip.length > 0) {
                                fileInZip = loadedZip.file(filesInZip[0]);
                             }
                        }

                        if (fileInZip) {
                            const decompressedFileData = await fileInZip.async("uint8array");
                            displayReceivedFile(decompressedFileData, receivedOriginalFileName, receivedOriginalFileType);
                            showStatus(receiverStatusMessage, "statusFileDecoded", false);
                            trackEvent('receive_ok', { 
                                fn: encodeURIComponent(receivedOriginalFileName), 
                                tt: 'direct' 
                            });
                        } else {
                            const userMessageKey = 'errorFileNotFoundInZip';
                            trackEvent('error', { ec: 'ZIP_NO_FILE', em: userMessageKey });
                            throw new Error(getText(userMessageKey));
                        }
                    } catch (zipError) {
                        console.error("JSZip processing error:", zipError);
                        const userMessageKey = 'errorZipProcessing';
                        trackEvent('error', { ec: 'ZIP_PROC_FAIL', em: userMessageKey, details: encodeURIComponent(zipError.message) });
                        throw new Error(getText(userMessageKey, zipError.message));
                    }
                } 
            } catch (error) {
                console.error("Failed to receive file:", error);
                receiverTitleElem.textContent = getText('receiverTitleError');
                showStatus(receiverStatusMessage, error.message, true); 
            } finally {
                showLoader(receiverLoader, false);
            }
        }

        function displayReceivedFile(data, fileName, fileType) {
            const blob = new Blob([data], { type: fileType });
            const objectUrl = URL.createObjectURL(blob);

            downloadButton.href = objectUrl;
            downloadButton.download = fileName; 
            downloadButton.classList.remove('hidden');

            filePreview.innerHTML = ''; 
            if (fileType.startsWith('text/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const pre = document.createElement('pre');
                    pre.textContent = e.target.result;
                    pre.className = 'whitespace-pre-wrap break-all text-left text-sm';
                    filePreview.appendChild(pre);
                    filePreview.classList.remove('hidden');
                };
                reader.readAsText(blob);
            } else if (fileType.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = objectUrl;
                img.alt = getText('previewLabel', fileName); 
                img.className = 'max-w-full h-auto rounded-md mx-auto';
                filePreview.appendChild(img);
                filePreview.classList.remove('hidden');
            } else {
                 filePreview.classList.add('hidden'); 
            }
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes'; 
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; 
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }
        
    </script>
</body>
</html>
